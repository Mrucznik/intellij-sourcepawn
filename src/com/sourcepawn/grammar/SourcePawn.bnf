
// structure based off https://github.com/JetBrains/intellij-haxe/blob/master/grammar/haXe.bnf

{
    parserClass="com.sourcepawn.parser.SourcePawnParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="SourcePawn"
    psiImplClassSuffix="Impl"
    psiPackage="com.sourcepawn.psi"
    psiImplPackage="com.sourcepawn.psi.impl"

    elementTypeHolderClass="com.sourcepawn.psi.SourcePawnTypes"
    elementTypeClass="com.sourcepawn.psi.SourcePawnElementType"
    tokenTypeClass="com.sourcepawn.psi.SourcePawnTokenType"

    // from http://www.compuphase.com/pawn/Pawn_Language_Guide.pdf
    tokens = [
        // asignment operators
        OP_EQ="="
        OP_INCEQ="+="
        OP_DECEQ="-="
        OP_MULEQ="*="
        OP_DIVEQ="/="
        OP_REMEQ="%="
        OP_BITSHIFTREQ=">>="
        OP_BITUSHIFTREQ=">>>="
        OP_BITSHIFTLEQ="<<="
        OP_BITANDEQ="&="
        OP_BITOREQ="|="
        OP_BITXOREQ="^="

        // relational operators
        OP_EQEQ="=="
        OP_NOTEQ="!="
        OP_LT="<"
        OP_LTEQ="<="
        OP_GT=">"
        OP_GTEQ=">="

        // arithmetic operators
        OP_ADD="+"
        OP_SUB="-"
        OP_MUL="*"
        OP_DIV="/"
        OP_REM="%"
        OP_INC="++"
        OP_DEC="--"

        // boolean opeartors
        OP_OR="||"
        OP_AND="&&"
        OP_NOT="!"

        // bitwise operators
        OP_BITOR="|"
        OP_BITXOR="^"
        OP_BITNOT="~"
        OP_BITAND="&"
        OP_BITSHIFTR=">>"
        OP_BITUSHIFTR=">>>"
        OP_BITSHIFTL="<<"

        // misc operators
        OP_DEFINED="defined"
        OP_SIZEOF="sizeof"
        OP_STATE="state"
        OP_TAGOF="tagof"

        // brackets
        BRACKET_SQUARE_L="["
        BRACKET_SQUARE_R="]"
        BRACKET_CURLY_L="{"
        BRACKET_CURLY_R="}"
        BRACKET_PARAN_L="("
        BRACKET_PARAN_R=")"

        // general syntax operators
        SYNTAX_ELLIPSIS="..."
        SYNTAX_DOT="."
        SYNTAX_COLON=":"
        SYNTAX_SEMICOLON=";"
        SYNTAX_QUESTION="?"
        SYNTAX_COMMA=","

        // keywords
        KEY_ASSERT="assert"
        KEY_BREAK="break"
        KEY_CASE="case"
        KEY_CONTINUE="continue"
        KEY_DEFAULT="default"
        KEY_DO="do"
        KEY_ELSE="else"
        KEY_EXIT="exit"
        KEY_FOR="for"
        KEY_GOTO="goto"
        KEY_IF="if"
        KEY_RETURN="return"
        KEY_SLEEP="sleep"
        KEY_STATE="state"
        KEY_SWITCH="switch"
        KEY_WHILE="while"

        // directives
        DIR_ASSERT="#assert"
        DIR_DEFINE="#define"
        DIR_ELSE="#else"
        DIR_ELSEIF="#elseif"
        DIR_ENDIF="#endif"
        DIR_ENDINPUT="#endinput"
        DIR_ERROR="#error"
        DIR_FILE="#file"
        DIR_IF="#if"
        DIR_INCLUDE="#include"
        DIR_LINE="#line"
        DIR_PRAGMA="#pragma"
        DIR_SECTION="#section"
        DIR_TRYINC="#tryinclude"
        DIR_UNDEF="#undef"

        // accessor modifiers
        MOD_FORWARD="forward"
        MOD_NATIVE="native"
        MOD_PUBLIC="public"
        MOD_STOCK="stock"
        MOD_STATIC="static"
        MOD_NEW="new"
        MOD_CONST="const"
        MOD_DECL="decl"
        MOD_ENUM="enum"
        MOD_STRUCT="struct"

        // types
        TYPE_FLOAT="regexp:\d+\.\d+"
        TYPE_NUMBER="regexp:-?\d+"
        TYPE_BOOLEAN="regexp:(true|false)"
        TYPE_STRING="regexp:\"([^\"\\]|\\.)*\""
        TYPE_CHARACTER="regexp:'\\?.'"

        // general
        ID='regexp:\p{Alpha}\w*'
        LINE_COMMENT="regexp://.*"
        BLOCK_COMMENT="regexp:/\*(.|\n)+?\*/"
    ]

    extends(".*(Expression|Literal)")="expression"
    pin(".*Expression")=1
    pin(".*(Statement|Directive)")=1
}

sourcepawnFile ::= topLevelList

private topLevelList ::= topLevel*
private topLevel ::= topLevelDeclaration {recoverWhile=top_level_recover}
private top_level_recover ::= !(SYNTAX_SEMICOLON | dirList | modList)

private topLevelDeclaration ::= directive
                                | structDeclaration
                                | functionDeclaration
                                | enumDeclaration
                                | globalVarDeclaration

/*
 generic
 */

identifier ::= ID
componentName ::= identifier
typeTag ::= componentName SYNTAX_COLON

/*
 operators
 */

// operator precedence from http://www.compuphase.com/pawn/Pawn_Language_Guide.pdf
assignOperation ::= OP_MULEQ | OP_DIVEQ | OP_REMEQ | OP_INCEQ | OP_DECEQ
                | OP_BITSHIFTREQ | OP_BITUSHIFTREQ | OP_BITSHIFTLEQ | OP_BITANDEQ | OP_BITXOREQ | OP_BITOREQ
                | OP_EQ
shiftOperator ::= OP_BITSHIFTL | OP_BITUSHIFTR | OP_BITSHIFTR

// todo: is there a way to automate this?
private operatorList ::= OP_EQ | OP_INCEQ | OP_DECEQ | OP_MULEQ | OP_DIVEQ | OP_REMEQ | OP_BITSHIFTREQ | OP_BITUSHIFTREQ | OP_BITSHIFTLEQ | OP_BITANDEQ | OP_BITOREQ | OP_BITXOREQ | OP_EQEQ | OP_NOTEQ | OP_LT | OP_LTEQ | OP_GT | OP_GTEQ | OP_ADD | OP_SUB | OP_MUL | OP_DIV | OP_REM | OP_INC | OP_DEC | OP_OR | OP_AND | OP_NOT | OP_BITOR | OP_BITXOR | OP_BITNOT | OP_BITAND | OP_BITSHIFTR | OP_BITUSHIFTR | OP_BITSHIFTL | OP_DEFINED | OP_SIZEOF | OP_STATE | OP_TAGOF
private bracketList ::= BRACKET_SQUARE_L | BRACKET_SQUARE_R | BRACKET_CURLY_L | BRACKET_CURLY_R | BRACKET_PARAN_L | BRACKET_PARAN_R
private syntaxList ::= SYNTAX_ELLIPSIS | SYNTAX_DOT | SYNTAX_COLON | SYNTAX_SEMICOLON | SYNTAX_QUESTION | SYNTAX_COMMA
private keyList ::= KEY_ASSERT | KEY_BREAK | KEY_CASE | KEY_CONTINUE | KEY_DEFAULT | KEY_DO | KEY_ELSE | KEY_EXIT | KEY_FOR | KEY_GOTO | KEY_IF | KEY_RETURN | KEY_SLEEP | KEY_STATE | KEY_SWITCH | KEY_WHILE
private dirList ::= DIR_ASSERT | DIR_DEFINE | DIR_ELSE | DIR_ELSEIF | DIR_ENDIF | DIR_ENDINPUT | DIR_ERROR | DIR_FILE | DIR_IF | DIR_INCLUDE | DIR_LINE | DIR_PRAGMA | DIR_SECTION | DIR_TRYINC | DIR_UNDEF
private modList ::= MOD_FORWARD | MOD_NATIVE | MOD_PUBLIC | MOD_STOCK | MOD_STATIC | MOD_NEW | MOD_CONST | MOD_DECL | MOD_ENUM | MOD_STRUCT

/*
 statement
 */

blockStatement ::= BRACKET_CURLY_L statementList? BRACKET_CURLY_R
private statementList ::= (statement SYNTAX_SEMICOLON?)+ {recoverWhile=statement_recovery}
private statement_recovery ::= !(BRACKET_CURLY_R | KEY_CASE | KEY_DEFAULT)

private statement ::= blockStatement | notBlockStatement

private notBlockStatement ::= localVarDeclaration
                            | ifStatement
                            | forStatement
                            | whileStatement
                            | doWhileStatement
                            | returnStatement
                            | breakStatement
                            | continueStatement
                            | switchStatement
                            | expression

/*
 directives
 */

directive ::= includeDirective
            | defineDirective | undefineDirective
            | pragmaDirective
            | ifDirective | elseifDirective | elseDirective | endifDirective

fileName ::= identifier
includeDirective ::= DIR_INCLUDE OP_LT? fileName OP_GT?
defineDirective ::= DIR_DEFINE identifier literalExpression? // todo: what about defining functions ?
undefineDirective ::= DIR_UNDEF identifier
pragmaDirective ::= DIR_PRAGMA identifier literalExpression
ifDirective ::= DIR_IF expression
elseifDirective ::= DIR_ELSEIF expression
elseDirective ::= DIR_ELSE
endifDirective ::= DIR_ENDIF
// todo: more directives

/*
 functions
 */

functionDeclaration ::= funcModifierList? typeTag? componentName BRACKET_PARAN_L parameterList? BRACKET_PARAN_R functionCommonBody
funcModifierList ::= MOD_FORWARD | MOD_NATIVE | MOD_PUBLIC | MOD_STOCK
private functionCommonBody ::= blockStatement | returnStatement | expression

/*
 parameter
 */

parameter ::= MOD_CONST? typeTag? componentName varInit?
parameterList ::= parameter (SYNTAX_COMMA parameter)* {recoverWhile=parameterListRecovery}
private parameterListRecovery ::= !BRACKET_PARAN_R

/*
 variables
 */

initBlockStatement ::= BRACKET_CURLY_L initStatementList? BRACKET_CURLY_R
private initStatementList ::= (statement SYNTAX_COMMA?)+ {recoverWhile=init_statement_recovery}
private init_statement_recovery ::= !(BRACKET_CURLY_R | KEY_CASE | KEY_DEFAULT)

varInit ::= OP_EQ (initBlockStatement | statement) {pin=1}

localVarModifier ::= MOD_STATIC | MOD_NEW | MOD_CONST | MOD_DECL
localVarDeclaration ::= localVarModifier varDeclarationPartList {pin=1}

globalVarModifier ::= MOD_PUBLIC | MOD_STATIC | MOD_NEW | MOD_CONST | MOD_DECL
globalVarDeclaration ::= globalVarModifier varDeclarationPartList SYNTAX_SEMICOLON? {pin=1}

private varDeclarationPartList ::= varDeclarationPart (SYNTAX_COMMA varDeclarationPart)* varInit? {recoverWhile=var_declaration_part_recover}
varDeclarationPart ::= typeTag? componentName arrayAccessExpression?
private var_declaration_part_recover ::= !(SYNTAX_SEMICOLON | BRACKET_CURLY_R | SYNTAX_COMMA | modList)

enumDeclaration ::= MOD_ENUM componentName BRACKET_CURLY_L enumBlock BRACKET_CURLY_R SYNTAX_SEMICOLON?
enumBlock ::= enumValueDeclaration*
enumValueDeclaration ::= componentName OP_EQ literalExpression SYNTAX_COMMA?

structDeclaration ::= MOD_STRUCT componentName BRACKET_CURLY_L structBlock BRACKET_CURLY_R SYNTAX_SEMICOLON? {pin=1}
structBlock ::= structValueDeclaration*
structValueDeclaration ::= MOD_CONST typeTag? componentName arrayAccessExpression? SYNTAX_COMMA?

/*
 statements
 */

returnStatement ::= KEY_RETURN expression?
ifStatement ::= KEY_IF BRACKET_PARAN_L expression BRACKET_PARAN_R statement* [KEY_ELSE statement*]
forStatement ::= KEY_FOR BRACKET_PARAN_L notBlockStatement? SYNTAX_SEMICOLON notBlockStatement? SYNTAX_SEMICOLON notBlockStatement? BRACKET_PARAN_R statement
whileStatement ::= KEY_WHILE BRACKET_PARAN_L expression BRACKET_PARAN_R statement
doWhileStatement ::= KEY_DO BRACKET_PARAN_L statement BRACKET_PARAN_R KEY_WHILE BRACKET_PARAN_L expression BRACKET_PARAN_R SYNTAX_SEMICOLON
breakStatement ::= KEY_BREAK
continueStatement ::= KEY_CONTINUE

switchStatement ::= KEY_SWITCH BRACKET_PARAN_L expression BRACKET_PARAN_R switchBlock
switchBlock ::= BRACKET_CURLY_L switchCase* defaultCase? BRACKET_CURLY_R {pin=1}
switchCaseBlock ::= statementList
switchCase ::= KEY_CASE literalExpression (SYNTAX_COMMA literalExpression)* SYNTAX_COLON switchCaseBlock? {pin=1 recoverWhile=switch_case_recover}
private switch_case_recover ::= !(KEY_CASE | KEY_DEFAULT | BRACKET_CURLY_R | identifier)
defaultCase::= KEY_DEFAULT SYNTAX_COLON switchCaseBlock? {pin=1}

/*
 expression
 */

// expression precedence from http://www.compuphase.com/pawn/Pawn_Language_Guide.pdf

expressionList ::= expression (SYNTAX_COMMA expression)* {recoverWhile=expression_list_recover}
private expression_list_recover ::= !(BRACKET_PARAN_R | BRACKET_SQUARE_R)

expression ::= assignExpressionWrapper {recoverWhile=expression_recover}
private expression_recover ::= !(operatorList | bracketList | syntaxList | keyList | dirList | modList)

private assignExpressionWrapper ::= ternaryExpressionWrapper assignExpression*
left assignExpression ::= assignOperation ternaryExpressionWrapper {pin=1 extends=expression}

private ternaryExpressionWrapper ::= logicOrExpressionWrapper ternaryExpression?
left ternaryExpression ::= SYNTAX_QUESTION expression SYNTAX_COLON ternaryExpressionWrapper

private logicOrExpressionWrapper ::= logicAndExpressionWrapper logicOrExpression*
left logicOrExpression ::= OP_OR logicAndExpressionWrapper

private logicAndExpressionWrapper ::= equalityExpressionWrapper logicAndExpression*
left logicAndExpression ::= OP_AND equalityExpressionWrapper

private equalityExpressionWrapper ::= comparisonExpressionWrapper equalityExpression*
left equalityExpression ::= (OP_NOTEQ | OP_EQEQ) comparisonExpressionWrapper

private comparisonExpressionWrapper ::= bitwiseOrExpressionWrapper compareExpression*
left compareExpression ::= (OP_GTEQ | OP_GT | OP_LTEQ | OP_LT) bitwiseOrExpressionWrapper

private bitwiseOrExpressionWrapper ::= bitwiseXOrExpressionWrapper bitwiseOrExpression*
left bitwiseOrExpression ::= OP_BITOR bitwiseXOrExpressionWrapper

private bitwiseXOrExpressionWrapper ::= bitwiseAndExpressionWrapper bitwiseXOrExpression*
left bitwiseXOrExpression ::= OP_BITXOR bitwiseAndExpressionWrapper

private bitwiseAndExpressionWrapper ::= shiftExpressionWrapper bitwiseAndExpression*
left bitwiseAndExpression ::= (OP_BITSHIFTL | OP_BITUSHIFTR | OP_BITSHIFTR) shiftExpressionWrapper

private shiftExpressionWrapper ::= additiveExpressionWrapper shiftExpression*
left shiftExpression ::= shiftOperator additiveExpressionWrapper

private additiveExpressionWrapper ::= multiplicativeExpressionWrapper additiveExpression*
left additiveExpression ::= (OP_ADD | OP_SUB) multiplicativeExpressionWrapper

private multiplicativeExpressionWrapper ::= prefixExpression multiplicativeExpression*
left multiplicativeExpression ::= (OP_MUL | OP_DIV | OP_REM) (prefixExpression | suffixExpressionWrapper)

// todo: not including SYNTX_COLON, include as a tagged value, is this ok?
prefixExpression ::= (OP_TAGOF | OP_STATE | OP_SIZEOF | OP_DEFINED | OP_DEC | OP_INC | OP_SUB | OP_BITNOT | OP_NOT) prefixExpression | suffixExpressionWrapper

private suffixExpressionWrapper ::= value suffixExpression?
left suffixExpression ::= (OP_DEC | OP_INC)

private value ::= literalExpression
                | SYTNAX_ELLIPSIS
                | arrayLiteral
                | parenthesizedExpression
                | callOrArrayAccess
                | referenceExpression

// todo: make these individual expressions ?
literalExpression ::= TYPE_FLOAT | TYPE_NUMBER | TYPE_BOOLEAN | TYPE_STRING | TYPE_CHARACTER

arrayLiteral ::= BRACKET_CURLY_L expressionList? BRACKET_CURLY_R

parenthesizedExpression ::= BRACKET_PARAN_L (expression | statement) BRACKET_PARAN_R

referenceExpression ::= identifier
private callOrArrayAccess ::= typeTag? referenceExpression (callExpression | arrayAccessExpression)
left callExpression ::= BRACKET_PARAN_L expressionList? BRACKET_PARAN_R
left arrayAccessExpression ::= BRACKET_SQUARE_L expression? BRACKET_SQUARE_R